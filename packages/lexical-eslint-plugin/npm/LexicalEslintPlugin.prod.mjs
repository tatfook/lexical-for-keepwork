/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];if("string"!=typeof i&&!Array.isArray(i))for(var r in i)"default"===r||r in e||(e[r]=i[r])}return e}function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var n={name:"@lexical/eslint-plugin",description:"Lexical specific linting rules for ESLint",keywords:["eslint","eslint-plugin","eslintplugin","lexical","editor"],version:"0.15.0",license:"MIT",repository:{type:"git",url:"git+https://github.com/facebook/lexical.git",directory:"packages/lexical-eslint-plugin"},main:"LexicalEslintPlugin.js",types:"index.d.ts",bugs:{url:"https://github.com/facebook/lexical/issues"},homepage:"https://lexical.dev/docs/packages/lexical-eslint-plugin",sideEffects:!1,peerDependencies:{eslint:">=7.31.0 || ^8.0.0"},exports:{".":{import:{types:"./index.d.ts",development:"./LexicalEslintPlugin.dev.mjs",production:"./LexicalEslintPlugin.prod.mjs",node:"./LexicalEslintPlugin.node.mjs",default:"./LexicalEslintPlugin.mjs"},require:{types:"./index.d.ts",development:"./LexicalEslintPlugin.dev.js",production:"./LexicalEslintPlugin.prod.js",default:"./LexicalEslintPlugin.js"}}},devDependencies:{"@types/eslint":"^8.56.9"},module:"LexicalEslintPlugin.mjs"},i={},r={},s={getParentAssignmentName:function(e){const t=e.parent;return"VariableDeclarator"===t.type&&t.init===e?t.id:"AssignmentExpression"===t.type&&t.right===e&&"="===t.operator?t.left:void 0}};const{getParentAssignmentName:o}=s;r.getFunctionName=function(e){return"FunctionDeclaration"===e.type||"FunctionExpression"===e.type&&e.id?e.id:"FunctionExpression"===e.type||"ArrowFunctionExpression"===e.type?o(e):void 0};var a={};a.buildMatcher=function(...e){const t=[],n=[];for(const r of e.flat(1))r&&("string"==typeof r?n.push(/^[(^]/.test(r)?r:`^${i=r,i.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}$`):r&&r instanceof RegExp?r.flags?t.push((e=>r.test(e))):n.push(r.source):"function"==typeof r&&t.push(r));var i;const r=n.map((e=>`(?:${e})`)).join("|");if(r){const e=new RegExp(r);t.push((t=>e.test(t)))}return e=>{if(e){if("Identifier"!==e.type)throw new Error(`Expecting Identifier, not ${e.type}`);for(const n of t)if(n(e.name,e))return!0}return!1}};const{getFunctionName:l}=r,{getParentAssignmentName:c}=s,{buildMatcher:u}=a;const p={isDollarFunction:[/^\$[a-z_]/],isIgnoredFunction:[],isLexicalProvider:["parseEditorState","read","registerCommand","registerNodeTransform","update"],isSafeDollarFunction:[/^\$is[A-Z_]/]};function d(e){if(e)return"Identifier"===e.type?e:"MemberExpression"!==e.type||e.computed?void 0:d(e.property)}function f(e,t){const n=Array.isArray(e.options)?e.options[0]:void 0;return n&&t in n?n[t]:void 0}const g={oneOf:[{type:"string"},{contains:{type:"string"},type:"array"}]};i.rulesOfLexical={create(e){const t=function(e){return e.getSourceCode()}(e),n=function(e){const t={};for(const n in p){const i=n;t[i]=u(p[i],f(e,i))}return t}(e),i=new Set,r=new Set,s=[],o=e=>i.add(e),a=e=>i.delete(e),g=e=>{const t=d(function(e){const t=l(e);if(t)return t;const n=e.parent;if("CallExpression"===n.type&&n.arguments[0]===e&&function(e){return e&&"Identifier"===e.type&&/^use([A-Z]|$)/.test(e.name)}(d(n.callee)))return c(n)}(e));s.push({name:t,node:e}),(n.isDollarFunction(t)||n.isIgnoredFunction(t)||n.isLexicalProvider(t))&&o(e)},x=e=>{s.pop(),a(e)};return{ArrowFunctionExpression:g,"ArrowFunctionExpression:exit":x,CallExpression:a=>{if((()=>{if(i.size>0)return!0;const e=s[s.length-1];return e&&"Property"===e.node.parent.type})())return;const l=d(a.callee);if(n.isLexicalProvider(l)||n.isSafeDollarFunction(l))return void o(a);if(!n.isDollarFunction(l))return;const c=(e=>{const t=s[s.length-1];return t?t.name:void 0})();if(!c||r.has(c))return;r.add(c);const u=function(e,t){const n=e.scopeManager;for(let e=t;e;e=e.parent){const i=n.getDeclaredVariables(e).find((e=>e.identifiers.includes(t)));if(i)return i;const r=n.acquire(e);if(r)return r.set.get(t.name)||(r.upper?r.upper.set.get(t.name):void 0)}}(t,c),p=function(e,t){const n=function(e){return/^[a-z]/.test(e)?"$"+e:/^[A-Z][a-z]/.test(e)?"$"+e.slice(0,1).toLowerCase()+e.slice(1):`$_${e}`}(e.name);if(t)for(let e=t.scope;e;e=e.upper)if(e.set.has(n))return n+"_";return n}(c,u),f=function(e){if(e&&1===e.defs.length){const[{node:t}]=e.defs;if("ExportNamedDeclaration"===t.parent.type)return t.parent;if("VariableDeclaration"===t.parent.type&&"ExportNamedDeclaration"===t.parent.parent.type)return t.parent.parent}}(u),g={callee:t.getText(a.callee),caller:t.getText(c),suggestName:p},x=e=>{const t=new Set,n=[],i=i=>{t.has(i)||(t.add(i),n.push(e.replaceText(i,p)))};if(i(c),f&&n.push(e.insertTextAfter(f,function({caller:e,suggestName:t}){return`\n/** @deprecated renamed to {@link ${t}} by @lexical/eslint-plugin rules-of-lexical */\nexport const ${e} = ${t};`}(g))),u)for(const e of u.references)i(e.identifier);return n};e.report({data:g,fix:x,messageId:"rulesOfLexicalReport",node:c,suggest:[{data:g,fix:x,messageId:"rulesOfLexicalSuggestion"}]})},"CallExpression:exit":a,ClassBody:o,"ClassBody:exit":a,FunctionDeclaration:g,"FunctionDeclaration:exit":x,FunctionExpression:g,"FunctionExpression:exit":x}},meta:{docs:{description:"enforces the Rules of Lexical",recommended:!0,url:"https://lexical.dev/docs/packages/lexical-eslint-plugin"},fixable:"code",hasSuggestions:!0,messages:{rulesOfLexicalReport:"{{ callee }} called from {{ caller }}, without $ prefix or read/update context",rulesOfLexicalSuggestion:"Rename {{ caller }} to {{ suggestName }}"},schema:[{additionalProperties:!1,properties:{isDollarFunction:g,isIgnoredFunction:g,isLexicalProvider:g,isSafeDollarFunction:g},type:"object"}],type:"suggestion"}};const{name:x,version:m}=n,{rulesOfLexical:y}=i,h={plugins:["@lexical"],rules:{"@lexical/rules-of-lexical":"warn"}};var E={configs:{all:h,recommended:h},meta:{name:x,version:m},rules:{"rules-of-lexical":y}},v=e({__proto__:null,default:t(E)},[E]);export{v as default};
